 Remove non-functional Advanced Options (UI only, keep working ones)
Goal: Hide/disable any Advanced Option that isn’t bound, isn’t validated, or is rejected by the backend—so users only see options that truly work. Do not change conversion logic or page layouts beyond removing broken controls.

1) Add a central capability map
Create config/advancedOptions.matrix.json with a per-tool list of known options.

Each option has a status: "supported" | "unknown" | "unsupported".

Default any ambiguous item to "unknown" (we will auto-detect at runtime and hide if it breaks).

Example:

json
Copy
Edit
{
  "mp4-to-mp3": { "audioBitrate": "supported", "audioFormat": "supported", "preserveMetadata": "supported", "normalizeAudio": "unknown" },
  "video-compress": { "targetBitrate": "supported", "scale": "supported", "fps": "unknown", "profile": "unsupported" },
  "gif-maker": { "start": "supported", "duration": "supported", "fps": "supported", "width": "supported", "quality": "unknown", "loop": "supported", "boomerang": "unknown" },
  "pdf-rotate": { "defaultRotation": "supported", "autoDetectOrientation": "unknown", "preserveAspect": "supported" },
  "pdf-watermark": { "pageRange": "supported", "behindText": "supported", "repeatPattern": "unknown" },
  "pdf-to-word": { "ocr": "supported", "preserveFormatting": "supported", "includeImages": "supported", "mode": "unknown" }
}
2) Add a tiny helper to prune broken options
Create client/js/utils/pruneOptions.js:

js
Copy
Edit
import matrix from "../../config/advancedOptions.matrix.json" assert { type: "json" };

function nearestOptionGroup(el) {
  return el?.closest?.(".option-group, .checkbox-group, .premium-checkbox-item, .option-row") || el;
}

export function hideOption(el, reason = "") {
  const grp = nearestOptionGroup(el);
  if (grp) grp.remove();
  if (window.console) console.info("[Options] Removed non-functional option:", reason || el?.id || el?.name);
}

// Hard rule: remove if matrix marks as unsupported
export function pruneByMatrix(toolKey, root = document) {
  const rules = matrix[toolKey] || {};
  Object.entries(rules).forEach(([key, status]) => {
    if (status === "unsupported") {
      const el = root.querySelector(`[id='${key}'], [name='${key}'], [data-option='${key}']`);
      if (el) hideOption(el, `${toolKey}.${key} marked unsupported`);
    }
  });
}

// Safe binder: if binding/validation fails, remove the control
export function bindOrPrune(toolKey, key, selector, binder, root = document) {
  try {
    const el = root.querySelector(selector);
    if (!el) throw new Error("missing element");
    // If matrix says unknown, let it try; if it throws, we prune.
    binder(el);
  } catch (e) {
    const el = root.querySelector(selector);
    if (el) hideOption(el, `${toolKey}.${key}: ${e.message}`);
  }
}

// After a backend error that targets a specific option, remove it for this session
export function pruneOnBackendError(toolKey, errorObj = {}, root = document) {
  const msg = (errorObj?.message || "").toLowerCase();
  const rules = matrix[toolKey] || {};
  Object.keys(rules).forEach((key) => {
    if (msg.includes(key.toLowerCase()) || msg.includes("unsupported") || msg.includes("invalid option")) {
      const el = root.querySelector(`[id='${key}'], [name='${key}'], [data-option='${key}']`);
      if (el) hideOption(el, `${toolKey}.${key} rejected by backend`);
    }
  });
}
3) Use the helper in each tool (UI only)
For each converter JS (only touching Advanced Options init), do:

At the top:

js
Copy
Edit
import { pruneByMatrix, bindOrPrune, pruneOnBackendError } from "../utils/pruneOptions.js";
const TOOL_KEY = "mp4-to-mp3"; // <- set the correct key per tool file
On page init (after DOMContentLoaded):

js
Copy
Edit
pruneByMatrix(TOOL_KEY, document);

// Bind each control safely:
bindOrPrune(TOOL_KEY, "audioBitrate", "#audioBitrate", (el) => {
  el.addEventListener("change", /* existing handler */);
});
bindOrPrune(TOOL_KEY, "audioFormat", "#audioFormat", (el) => {
  el.addEventListener("change", /* existing handler */);
});
bindOrPrune(TOOL_KEY, "preserveMetadata", "#preserveMetadata", (el) => {
  el.addEventListener("change", /* existing handler */);
});
// …repeat for the tool’s advanced controls
When sending the request payload:
Only include values that still exist:

js
Copy
Edit
function collectOptions(root = document) {
  const get = (sel) => root.querySelector(sel);
  const payload = {};
  const bitrate = get("#audioBitrate"); if (bitrate) payload.audioBitrate = bitrate.value;
  const fmt = get("#audioFormat"); if (fmt) payload.audioFormat = fmt.value;
  const meta = get("#preserveMetadata"); if (meta) payload.preserveMetadata = !!meta.checked;
  // …repeat
  return payload;
}
On backend error (in your .catch or non-200 branch):

js
Copy
Edit
.catch(async (err) => {
  // existing inline error UI…
  const serverErr = err?.responseJSON || err; // adapt to your fetch/axios shape
  pruneOnBackendError(TOOL_KEY, serverErr, document);
});
4) Do NOT ship broken options
If an option element no longer exists (because it was pruned), do not add it to the payload.

No toasts. Keep current inline error UI.

5) Keep layout tidy
No extra CSS needed—removing the .option-group keeps spacing consistent.

Make sure the Advanced Options container remains if at least one option survives; if empty, remove the whole .advanced-options block.

6) Report
After changes, print a one-time console summary on load with any options removed (tool key + option key). Don’t render anything new in the UI.

Acceptance
Each tool keeps working exactly as before.

Any advanced option that isn’t bound, validated, or is rejected by the backend is removed from the UI and not sent.

No regressions to upload/convert, no layout breakage.

A console summary shows which options were removed.